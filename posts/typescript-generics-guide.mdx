---
title: "Understanding TypeScript Generics: A Practical Guide"
description: "Master TypeScript generics with real-world examples, advanced patterns, and best practices for building type-safe, reusable code components."
date: "2024-11-20"
author: "Tech Blogger"
tags: ["TypeScript", "JavaScript", "Programming"]
image: "/images/typescript-generics.jpg"
readTime: "8 min read"
---

# Understanding TypeScript Generics: A Practical Guide

TypeScript generics are one of the most powerful features for creating flexible, reusable, and type-safe code. If you've ever found yourself writing similar functions or classes that work with different types, generics are your solution.

## What Are Generics?

Generics allow you to create components that work with multiple types while preserving type information. Think of them as placeholders for types that get filled in when the component is used.

```typescript
// Without generics - limited and repetitive
function identityString(arg: string): string {
  return arg;
}

function identityNumber(arg: number): number {
  return arg;
}

// With generics - flexible and reusable
function identity<T>(arg: T): T {
  return arg;
}

// Usage
const stringResult = identity<string>("hello"); // Type: string
const numberResult = identity<number>(42); // Type: number
const booleanResult = identity(true); // Type inferred as boolean
```

## Basic Generic Functions

Let's start with practical examples you'll use every day:

```typescript
// Generic array operations
function getFirstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

const firstString = getFirstElement(["a", "b", "c"]); // string | undefined
const firstNumber = getFirstElement([1, 2, 3]); // number | undefined

// Generic pair creation
function createPair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

const stringNumberPair = createPair("hello", 42); // [string, number]
const booleanDatePair = createPair(true, new Date()); // [boolean, Date]
```

## Generic Interfaces and Types

Generics really shine when building reusable data structures:

```typescript
// Generic API response wrapper
interface ApiResponse<TData> {
  data: TData;
  success: boolean;
  message: string;
  timestamp: Date;
}

// Usage with different data types
type UserResponse = ApiResponse<{
  id: number;
  name: string;
  email: string;
}>;

type ProductResponse = ApiResponse<{
  id: string;
  title: string;
  price: number;
}>;

// Generic repository pattern
interface Repository<TEntity, TId = string> {
  findById(id: TId): Promise<TEntity | null>;
  findAll(): Promise<TEntity[]>;
  create(entity: Omit<TEntity, 'id'>): Promise<TEntity>;
  update(id: TId, updates: Partial<TEntity>): Promise<TEntity>;
  delete(id: TId): Promise<void>;
}
```

## Generic Classes

Classes become incredibly powerful with generics:

```typescript
// Generic data store
class DataStore<T> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  findById<K extends keyof T>(key: K, value: T[K]): T | undefined {
    return this.items.find(item => item[key] === value);
  }

  getAll(): T[] {
    return [...this.items];
  }

  filter(predicate: (item: T) => boolean): T[] {
    return this.items.filter(predicate);
  }
}

// Usage
interface User {
  id: number;
  name: string;
  email: string;
}

const userStore = new DataStore<User>();
userStore.add({ id: 1, name: "John", email: "john@example.com" });

const user = userStore.findById("email", "john@example.com");
```

## Advanced Generic Constraints

Constraints help you specify what types are acceptable:

```typescript
// Constraining to objects with specific properties
interface HasId {
  id: string | number;
}

function updateEntity<T extends HasId>(entity: T, updates: Partial<T>): T {
  return { ...entity, ...updates };
}

// Constraining to specific type unions
function processValue<T extends string | number>(value: T): T {
  // TypeScript knows value is either string or number
  console.log(`Processing: ${value}`);
  return value;
}

// Keyof constraint for property access
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Alice", age: 30, city: "NYC" };
const name = getProperty(person, "name"); // Type: string
const age = getProperty(person, "age"); // Type: number
```

## Generic Utility Types in Practice

TypeScript's built-in utility types are powerful generic examples:

```typescript
// Custom utility types
type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

interface User {
  id: number;
  name: string;
  email: string;
  avatar: string;
}

// Make avatar optional
type UserInput = Optional<User, 'avatar'>;

// Deep readonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object
    ? DeepReadonly<T[P]>
    : T[P];
};

// Conditional types with generics
type ApiResult<T> = T extends string
  ? { message: T }
  : T extends number
  ? { count: T }
  : { data: T };

type StringResult = ApiResult<string>; // { message: string }
type NumberResult = ApiResult<number>; // { count: number }
type ObjectResult = ApiResult<User>; // { data: User }
```

## Real-World Example: Generic HTTP Client

Here's a practical example you might use in production:

```typescript
class HttpClient {
  private baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  async get<TResponse>(endpoint: string): Promise<TResponse> {
    const response = await fetch(`${this.baseUrl}${endpoint}`);
    return response.json();
  }

  async post<TRequest, TResponse>(
    endpoint: string,
    data: TRequest
  ): Promise<TResponse> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    return response.json();
  }

  async put<TRequest, TResponse>(
    endpoint: string,
    data: TRequest
  ): Promise<TResponse> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    return response.json();
  }
}

// Usage
const api = new HttpClient('https://api.example.com');

interface CreateUserRequest {
  name: string;
  email: string;
}

interface CreateUserResponse {
  id: number;
  name: string;
  email: string;
  createdAt: string;
}

// Fully typed API calls
const newUser = await api.post<CreateUserRequest, CreateUserResponse>(
  '/users',
  { name: 'John', email: 'john@example.com' }
);

const users = await api.get<User[]>('/users');
```

## Best Practices and Common Pitfalls

### 1. Use meaningful generic names
```typescript
// Bad
function process<T, U, V>(a: T, b: U): V { ... }

// Good
function mapUserToDto<TUser, TDto>(user: TUser, mapper: (u: TUser) => TDto): TDto { ... }
```

### 2. Don't over-constrain
```typescript
// Sometimes too specific
function logLength<T extends { length: number }>(item: T): T {
  console.log(item.length);
  return item;
}

// More flexible
function logLength<T>(item: T & { length: number }): T {
  console.log(item.length);
  return item;
}
```

### 3. Use default type parameters
```typescript
interface PaginatedResponse<T, TMeta = { total: number; page: number }> {
  data: T[];
  meta: TMeta;
}

// Can use with default meta
const users: PaginatedResponse<User> = await fetchUsers();

// Or with custom meta
const products: PaginatedResponse<Product, CustomMeta> = await fetchProducts();
```

## Conclusion

TypeScript generics transform how we write reusable code. They provide:

- **Type Safety**: Catch errors at compile time
- **Flexibility**: Work with multiple types seamlessly
- **Reusability**: Write code once, use everywhere
- **IntelliSense**: Better IDE support and autocompletion

Start incorporating generics into your utility functions, API clients, and data structures. Your future self (and your team) will thank you for the improved type safety and code reuse.

The key is to start simple and gradually incorporate more advanced patterns as you become comfortable. Happy coding!