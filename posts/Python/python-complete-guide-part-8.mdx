---
title: "Python from A to Z: Part 8 - Interview Algorithms and Patterns"
description: "Master common coding interview algorithms, patterns, and problem-solving strategies. Includes time complexity, NumPy, Pandas, and 50+ practice problems with solutions."
date: "2025-10-24"
author: "Goutham"
tags: ["Python", "Algorithms", "Interview Prep", "Data Science", "LeetCode"]
image: "/images/python-algorithms.svg"
readTime: "25 min read"
---

# Python from A to Z: Part 8 - Interview Algorithms and Patterns

The final chapter! Master algorithms, patterns, and problem-solving for technical interviews.

## Time & Space Complexity

### Big O Notation

```python
# O(1) - Constant
def get_first(arr):
    return arr[0]

# O(log n) - Logarithmic
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# O(n) - Linear
def find_max(arr):
    max_val = arr[0]
    for num in arr:
        if num > max_val:
            max_val = num
    return max_val

# O(n log n) - Linearithmic
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

# O(nÂ²) - Quadratic
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# O(2^n) - Exponential
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

## Common Interview Patterns

### 1. Two Pointers

```python
# Palindrome check
def is_palindrome(s):
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

# Remove duplicates from sorted array
def remove_duplicates(nums):
    if not nums:
        return 0
    slow = 0
    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
    return slow + 1

# Container with most water
def max_area(height):
    max_area = 0
    left, right = 0, len(height) - 1

    while left < right:
        width = right - left
        area = min(height[left], height[right]) * width
        max_area = max(max_area, area)

        if height[left] < height[right]:
            left += 1
        else:
            right -= 1

    return max_area
```

### 2. Sliding Window

```python
# Maximum sum of k consecutive elements
def max_sum_subarray(arr, k):
    window_sum = sum(arr[:k])
    max_sum = window_sum

    for i in range(k, len(arr)):
        window_sum = window_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, window_sum)

    return max_sum

# Longest substring without repeating characters
def length_of_longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length
```

### 3. Fast & Slow Pointers

```python
# Detect cycle in linked list
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    slow = fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True

    return False

# Find middle of linked list
def find_middle(head):
    slow = fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    return slow
```

### 4. Hash Table Pattern

```python
# Two Sum
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []

# Group Anagrams
def group_anagrams(strs):
    anagrams = {}
    for s in strs:
        key = ''.join(sorted(s))
        anagrams.setdefault(key, []).append(s)
    return list(anagrams.values())

# First non-repeating character
def first_unique_char(s):
    count = {}
    for char in s:
        count[char] = count.get(char, 0) + 1

    for i, char in enumerate(s):
        if count[char] == 1:
            return i

    return -1
```

### 5. Stack Pattern

```python
# Valid parentheses
def is_valid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in mapping:
            top = stack.pop() if stack else '#'
            if mapping[char] != top:
                return False
        else:
            stack.append(char)

    return not stack

# Daily temperatures
def daily_temperatures(temps):
    result = [0] * len(temps)
    stack = []  # Store indices

    for i, temp in enumerate(temps):
        while stack and temps[stack[-1]] < temp:
            prev_index = stack.pop()
            result[prev_index] = i - prev_index
        stack.append(i)

    return result
```

### 6. Binary Search

```python
# Standard binary search
def binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

# Find first and last position
def search_range(nums, target):
    def find_bound(is_first):
        left, right = 0, len(nums) - 1
        result = -1

        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                result = mid
                if is_first:
                    right = mid - 1
                else:
                    left = mid + 1
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return result

    return [find_bound(True), find_bound(False)]
```

## Sorting Algorithms

```python
# Quick Sort - O(n log n) average
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Merge Sort - O(n log n)
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

## Dynamic Programming

```python
# Fibonacci with memoization
def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]

# Climbing stairs
def climb_stairs(n):
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

# Coin change
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# Longest increasing subsequence
def length_of_lis(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)
```

## NumPy Essentials

```python
import numpy as np

# Creating arrays
arr1 = np.array([1, 2, 3, 4, 5])
arr2 = np.zeros((3, 3))  # 3x3 array of zeros
arr3 = np.ones((2, 4))   # 2x4 array of ones
arr4 = np.arange(0, 10, 2)  # [0, 2, 4, 6, 8]
arr5 = np.linspace(0, 1, 5)  # 5 evenly spaced values

# Array operations
print(arr1 + 10)  # [11, 12, 13, 14, 15]
print(arr1 * 2)   # [2, 4, 6, 8, 10]
print(arr1 ** 2)  # [1, 4, 9, 16, 25]

# Statistical operations
print(np.mean(arr1))   # 3.0
print(np.median(arr1)) # 3.0
print(np.std(arr1))    # Standard deviation
print(np.min(arr1))    # 1
print(np.max(arr1))    # 5

# Matrix operations
matrix = np.array([[1, 2], [3, 4]])
print(matrix.T)  # Transpose
print(np.dot(matrix, matrix))  # Matrix multiplication

# Boolean indexing
arr = np.array([1, 2, 3, 4, 5])
print(arr[arr > 2])  # [3, 4, 5]
```

## Pandas Essentials

```python
import pandas as pd

# Creating DataFrames
df = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [25, 30, 35],
    'City': ['NYC', 'LA', 'Chicago']
})

# Reading data
# df = pd.read_csv('data.csv')
# df = pd.read_excel('data.xlsx')
# df = pd.read_json('data.json')

# Basic operations
print(df.head())     # First 5 rows
print(df.tail())     # Last 5 rows
print(df.shape)      # (rows, columns)
print(df.info())     # Column info
print(df.describe()) # Statistics

# Accessing data
print(df['Name'])             # Column
print(df[['Name', 'Age']])    # Multiple columns
print(df.iloc[0])             # Row by index
print(df.loc[0, 'Name'])      # Specific cell

# Filtering
print(df[df['Age'] > 25])
print(df[df['City'] == 'NYC'])

# Sorting
df_sorted = df.sort_values('Age', ascending=False)

# Grouping
grouped = df.groupby('City').mean()

# Adding columns
df['Age_Next_Year'] = df['Age'] + 1

# Handling missing values
df.dropna()  # Remove NaN
df.fillna(0)  # Fill NaN with 0

# Applying functions
df['Age'].apply(lambda x: x * 2)
```

## Common Interview Problems

### Arrays

```python
# 1. Maximum subarray sum (Kadane's algorithm)
def max_subarray(nums):
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum

# 2. Rotate array
def rotate(nums, k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]

# 3. Product of array except self
def product_except_self(nums):
    n = len(nums)
    result = [1] * n

    # Left products
    left = 1
    for i in range(n):
        result[i] = left
        left *= nums[i]

    # Right products
    right = 1
    for i in range(n-1, -1, -1):
        result[i] *= right
        right *= nums[i]

    return result
```

### Strings

```python
# 1. Reverse words
def reverse_words(s):
    return ' '.join(s.split()[::-1])

# 2. Is subsequence
def is_subsequence(s, t):
    i = 0
    for char in t:
        if i < len(s) and s[i] == char:
            i += 1
    return i == len(s)

# 3. Longest common prefix
def longest_common_prefix(strs):
    if not strs:
        return ""

    for i in range(len(strs[0])):
        char = strs[0][i]
        for string in strs[1:]:
            if i >= len(string) or string[i] != char:
                return strs[0][:i]

    return strs[0]
```

### Trees

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 1. Maximum depth
def max_depth(root):
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))

# 2. Validate BST
def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    if not root:
        return True

    if root.val <= min_val or root.val >= max_val:
        return False

    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))

# 3. Level order traversal
def level_order(root):
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.pop(0)
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)

    return result
```

## Interview Tips

### Problem-Solving Framework

1. **Clarify**: Ask questions, understand constraints
2. **Examples**: Work through examples, edge cases
3. **Approach**: Discuss multiple solutions
4. **Code**: Write clean, readable code
5. **Test**: Test with examples, edge cases
6. **Optimize**: Discuss time/space complexity

### Common Pitfalls

```python
# â Modifying list while iterating
for item in my_list:
    if condition:
        my_list.remove(item)  # Bug!

# â Iterate over copy
for item in my_list[:]:
    if condition:
        my_list.remove(item)

# â Mutable default argument
def append_to(element, to=[]):  # Bug!
    to.append(element)
    return to

# â Use None as default
def append_to(element, to=None):
    if to is None:
        to = []
    to.append(element)
    return to
```

## Practice Problem Set

```python
# Easy
1. Reverse string
2. Two sum
3. Valid parentheses
4. Merge sorted arrays
5. Remove duplicates

# Medium
6. Longest substring without repeating
7. Container with most water
8. Three sum
9. Group anagrams
10. Spiral matrix

# Hard
11. Trapping rain water
12. Word ladder
13. Median of two sorted arrays
14. Regular expression matching
15. Merge k sorted lists
```

## Final Interview Checklist

â Know time/space complexity
â Master common patterns (two pointers, sliding window, etc.)
â Practice 100+ LeetCode problems
â Understand data structures deeply
â Code without IDE first
â Think out loud during interviews
â Write clean, readable code
â Test with edge cases
â Ask clarifying questions
â Stay calm and confident

## Congratulations! ð

You've completed Python from A to Z! You now have:

- â Solid Python fundamentals
- â Advanced programming concepts
- â Interview algorithm knowledge
- â Problem-solving skills
- â Real-world coding patterns

**Next Steps**:
1. Practice daily on LeetCode/HackerRank
2. Build projects to apply knowledge
3. Contribute to open source
4. Teach others (best way to learn)
5. Keep coding!

**Remember**: Consistency beats intensity. Code every day, even if just for 30 minutes. Good luck with your interviews! ð

---

*Series Complete: You're now ready for Python technical interviews!*
