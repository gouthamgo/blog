---
title: "Python from A to Z: Part 8 - Interview Algorithms and Patterns"
description: "Master common coding interview algorithms, patterns, and problem-solving strategies. Includes time complexity, NumPy, Pandas, and 50+ practice problems with solutions."
date: "2025-10-24"
author: "Goutham"
tags: ["Python", "Algorithms", "Interview Prep", "Data Science", "LeetCode"]
image: "/images/python-algorithms.svg"
readTime: "25 min read"
---

# Python from A to Z: Part 8 - Interview Algorithms and Patterns

The final chapter! Master algorithms, patterns, and problem-solving for technical interviews.

## Time & Space Complexity

### Big O Notation

```python
# O(1) - Constant
def get_first(arr):
    return arr[0]

# O(log n) - Logarithmic
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# O(n) - Linear
def find_max(arr):
    max_val = arr[0]
    for num in arr:
        if num > max_val:
            max_val = num
    return max_val

# O(n log n) - Linearithmic
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

# O(n¬≤) - Quadratic
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# O(2^n) - Exponential
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

## Common Interview Patterns

### 1. Two Pointers

```python
# Palindrome check
def is_palindrome(s):
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

# Remove duplicates from sorted array
def remove_duplicates(nums):
    if not nums:
        return 0
    slow = 0
    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
    return slow + 1

# Container with most water
def max_area(height):
    max_area = 0
    left, right = 0, len(height) - 1

    while left < right:
        width = right - left
        area = min(height[left], height[right]) * width
        max_area = max(max_area, area)

        if height[left] < height[right]:
            left += 1
        else:
            right -= 1

    return max_area
```

### 2. Sliding Window

```python
# Maximum sum of k consecutive elements
def max_sum_subarray(arr, k):
    window_sum = sum(arr[:k])
    max_sum = window_sum

    for i in range(k, len(arr)):
        window_sum = window_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, window_sum)

    return max_sum

# Longest substring without repeating characters
def length_of_longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length
```

### 3. Fast & Slow Pointers

```python
# Detect cycle in linked list
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    slow = fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True

    return False

# Find middle of linked list
def find_middle(head):
    slow = fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    return slow
```

### 4. Hash Table Pattern

```python
# Two Sum
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []

# Group Anagrams
def group_anagrams(strs):
    anagrams = {}
    for s in strs:
        key = ''.join(sorted(s))
        anagrams.setdefault(key, []).append(s)
    return list(anagrams.values())

# First non-repeating character
def first_unique_char(s):
    count = {}
    for char in s:
        count[char] = count.get(char, 0) + 1

    for i, char in enumerate(s):
        if count[char] == 1:
            return i

    return -1
```

### 5. Stack Pattern

```python
# Valid parentheses
def is_valid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in mapping:
            top = stack.pop() if stack else '#'
            if mapping[char] != top:
                return False
        else:
            stack.append(char)

    return not stack

# Daily temperatures
def daily_temperatures(temps):
    result = [0] * len(temps)
    stack = []  # Store indices

    for i, temp in enumerate(temps):
        while stack and temps[stack[-1]] < temp:
            prev_index = stack.pop()
            result[prev_index] = i - prev_index
        stack.append(i)

    return result
```

### 6. Binary Search

```python
# Standard binary search
def binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

# Find first and last position
def search_range(nums, target):
    def find_bound(is_first):
        left, right = 0, len(nums) - 1
        result = -1

        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                result = mid
                if is_first:
                    right = mid - 1
                else:
                    left = mid + 1
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return result

    return [find_bound(True), find_bound(False)]
```

## Sorting Algorithms

```python
# Quick Sort - O(n log n) average
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Merge Sort - O(n log n)
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

## Dynamic Programming

```python
# Fibonacci with memoization
def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]

# Climbing stairs
def climb_stairs(n):
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

# Coin change
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# Longest increasing subsequence
def length_of_lis(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)
```

## NumPy Essentials

```python
import numpy as np

# Creating arrays
arr1 = np.array([1, 2, 3, 4, 5])
arr2 = np.zeros((3, 3))  # 3x3 array of zeros
arr3 = np.ones((2, 4))   # 2x4 array of ones
arr4 = np.arange(0, 10, 2)  # [0, 2, 4, 6, 8]
arr5 = np.linspace(0, 1, 5)  # 5 evenly spaced values

# Array operations
print(arr1 + 10)  # [11, 12, 13, 14, 15]
print(arr1 * 2)   # [2, 4, 6, 8, 10]
print(arr1 ** 2)  # [1, 4, 9, 16, 25]

# Statistical operations
print(np.mean(arr1))   # 3.0
print(np.median(arr1)) # 3.0
print(np.std(arr1))    # Standard deviation
print(np.min(arr1))    # 1
print(np.max(arr1))    # 5

# Matrix operations
matrix = np.array([[1, 2], [3, 4]])
print(matrix.T)  # Transpose
print(np.dot(matrix, matrix))  # Matrix multiplication

# Boolean indexing
arr = np.array([1, 2, 3, 4, 5])
print(arr[arr > 2])  # [3, 4, 5]
```

## Pandas Essentials

```python
import pandas as pd

# Creating DataFrames
df = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [25, 30, 35],
    'City': ['NYC', 'LA', 'Chicago']
})

# Reading data
# df = pd.read_csv('data.csv')
# df = pd.read_excel('data.xlsx')
# df = pd.read_json('data.json')

# Basic operations
print(df.head())     # First 5 rows
print(df.tail())     # Last 5 rows
print(df.shape)      # (rows, columns)
print(df.info())     # Column info
print(df.describe()) # Statistics

# Accessing data
print(df['Name'])             # Column
print(df[['Name', 'Age']])    # Multiple columns
print(df.iloc[0])             # Row by index
print(df.loc[0, 'Name'])      # Specific cell

# Filtering
print(df[df['Age'] > 25])
print(df[df['City'] == 'NYC'])

# Sorting
df_sorted = df.sort_values('Age', ascending=False)

# Grouping
grouped = df.groupby('City').mean()

# Adding columns
df['Age_Next_Year'] = df['Age'] + 1

# Handling missing values
df.dropna()  # Remove NaN
df.fillna(0)  # Fill NaN with 0

# Applying functions
df['Age'].apply(lambda x: x * 2)
```

## Common Interview Problems

### Arrays

```python
# 1. Maximum subarray sum (Kadane's algorithm)
def max_subarray(nums):
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum

# 2. Rotate array
def rotate(nums, k):
    k = k % len(nums)
    nums[:] = nums[-k:] + nums[:-k]

# 3. Product of array except self
def product_except_self(nums):
    n = len(nums)
    result = [1] * n

    # Left products
    left = 1
    for i in range(n):
        result[i] = left
        left *= nums[i]

    # Right products
    right = 1
    for i in range(n-1, -1, -1):
        result[i] *= right
        right *= nums[i]

    return result
```

### Strings

```python
# 1. Reverse words
def reverse_words(s):
    return ' '.join(s.split()[::-1])

# 2. Is subsequence
def is_subsequence(s, t):
    i = 0
    for char in t:
        if i < len(s) and s[i] == char:
            i += 1
    return i == len(s)

# 3. Longest common prefix
def longest_common_prefix(strs):
    if not strs:
        return ""

    for i in range(len(strs[0])):
        char = strs[0][i]
        for string in strs[1:]:
            if i >= len(string) or string[i] != char:
                return strs[0][:i]

    return strs[0]
```

### Trees

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 1. Maximum depth
def max_depth(root):
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))

# 2. Validate BST
def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    if not root:
        return True

    if root.val <= min_val or root.val >= max_val:
        return False

    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))

# 3. Level order traversal
def level_order(root):
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.pop(0)
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)

    return result
```

## Interview Tips

### Problem-Solving Framework

1. **Clarify**: Ask questions, understand constraints
2. **Examples**: Work through examples, edge cases
3. **Approach**: Discuss multiple solutions
4. **Code**: Write clean, readable code
5. **Test**: Test with examples, edge cases
6. **Optimize**: Discuss time/space complexity

### Common Pitfalls

```python
# ‚ùå Modifying list while iterating
for item in my_list:
    if condition:
        my_list.remove(item)  # Bug!

# ‚úÖ Iterate over copy
for item in my_list[:]:
    if condition:
        my_list.remove(item)

# ‚ùå Mutable default argument
def append_to(element, to=[]):  # Bug!
    to.append(element)
    return to

# ‚úÖ Use None as default
def append_to(element, to=None):
    if to is None:
        to = []
    to.append(element)
    return to
```

## Practice Problem Set

```python
# Easy
1. Reverse string
2. Two sum
3. Valid parentheses
4. Merge sorted arrays
5. Remove duplicates

# Medium
6. Longest substring without repeating
7. Container with most water
8. Three sum
9. Group anagrams
10. Spiral matrix

# Hard
11. Trapping rain water
12. Word ladder
13. Median of two sorted arrays
14. Regular expression matching
15. Merge k sorted lists
```

## Final Interview Checklist

‚úÖ Know time/space complexity
‚úÖ Master common patterns (two pointers, sliding window, etc.)
‚úÖ Practice 100+ LeetCode problems
‚úÖ Understand data structures deeply
‚úÖ Code without IDE first
‚úÖ Think out loud during interviews
‚úÖ Write clean, readable code
‚úÖ Test with edge cases
‚úÖ Ask clarifying questions
‚úÖ Stay calm and confident

## Congratulations! üéâ

You've completed Python from A to Z! You now have:

- ‚úÖ Solid Python fundamentals
- ‚úÖ Advanced programming concepts
- ‚úÖ Interview algorithm knowledge
- ‚úÖ Problem-solving skills
- ‚úÖ Real-world coding patterns

**Next Steps**:
1. Practice daily on LeetCode/HackerRank
2. Build projects to apply knowledge
3. Contribute to open source
4. Teach others (best way to learn)
5. Keep coding!

**Remember**: Consistency beats intensity. Code every day, even if just for 30 minutes. Good luck with your interviews! üöÄ

---

*Series Complete: You're now ready for Python technical interviews!*
