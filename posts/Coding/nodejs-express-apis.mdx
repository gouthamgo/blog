---
title: "Building RESTful APIs with Node.js and Express"
description: "Learn to build robust, scalable REST APIs with Node.js and Express, covering authentication, validation, error handling, and production best practices."
date: "2025-11-05"
author: "Tech Blogger"
tags: ["Node.js", "API", "Backend"]
image: "/images/nodejs-express.jpg"
readTime: "9 min read"
---

# Building RESTful APIs with Node.js and Express

Node.js and Express form one of the most popular combinations for building REST APIs. This guide covers everything from basic setup to production-ready patterns that scale.

## Setting Up Your Express API

### Project Structure

```
my-api/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ utils/
â”‚   â””â”€â”€ app.js
â”œâ”€â”€ tests/
â”œâ”€â”€ package.json
â””â”€â”€ server.js
```

### Basic Express Setup

```javascript
// server.js
const app = require('./src/app');
const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// src/app.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

const app = express();

// Security middleware
app.use(helmet());
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
  credentials: true
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use(limiter);

// Body parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/auth', require('./routes/auth'));
app.use('/api/users', require('./routes/users'));
app.use('/api/posts', require('./routes/posts'));

// Global error handler
app.use(require('./middleware/errorHandler'));

module.exports = app;
```

## RESTful Route Design

### Resource-Based URLs

```javascript
// routes/users.js
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const auth = require('../middleware/auth');
const validate = require('../middleware/validate');
const { userSchemas } = require('../utils/validationSchemas');

// GET /api/users - List all users
router.get('/', auth.optional, userController.getUsers);

// GET /api/users/:id - Get specific user
router.get('/:id', auth.optional, userController.getUser);

// POST /api/users - Create new user
router.post('/',
  validate(userSchemas.create),
  userController.createUser
);

// PUT /api/users/:id - Update user (full update)
router.put('/:id',
  auth.required,
  validate(userSchemas.update),
  userController.updateUser
);

// PATCH /api/users/:id - Partial update
router.patch('/:id',
  auth.required,
  validate(userSchemas.patch),
  userController.patchUser
);

// DELETE /api/users/:id - Delete user
router.delete('/:id',
  auth.required,
  userController.deleteUser
);

// Nested resources
// GET /api/users/:id/posts - Get user's posts
router.get('/:id/posts', userController.getUserPosts);

module.exports = router;
```

## Controllers and Business Logic

### User Controller Example

```javascript
// controllers/userController.js
const userService = require('../services/userService');
const { AppError, catchAsync } = require('../utils/errorUtils');

exports.getUsers = catchAsync(async (req, res) => {
  // Query parameters for filtering, sorting, pagination
  const {
    page = 1,
    limit = 10,
    sort = 'createdAt',
    order = 'desc',
    search,
    status
  } = req.query;

  const filters = {};
  if (search) {
    filters.name = { $regex: search, $options: 'i' };
  }
  if (status) {
    filters.status = status;
  }

  const options = {
    page: parseInt(page),
    limit: parseInt(limit),
    sort: { [sort]: order === 'desc' ? -1 : 1 }
  };

  const result = await userService.getUsers(filters, options);

  res.json({
    success: true,
    data: result.users,
    pagination: {
      page: result.page,
      limit: result.limit,
      total: result.total,
      pages: Math.ceil(result.total / result.limit)
    }
  });
});

exports.getUser = catchAsync(async (req, res) => {
  const { id } = req.params;

  const user = await userService.getUserById(id);
  if (!user) {
    throw new AppError('User not found', 404);
  }

  res.json({
    success: true,
    data: user
  });
});

exports.createUser = catchAsync(async (req, res) => {
  const userData = req.body;

  const existingUser = await userService.getUserByEmail(userData.email);
  if (existingUser) {
    throw new AppError('Email already exists', 409);
  }

  const user = await userService.createUser(userData);

  res.status(201).json({
    success: true,
    data: user,
    message: 'User created successfully'
  });
});

exports.updateUser = catchAsync(async (req, res) => {
  const { id } = req.params;
  const updates = req.body;

  // Check if user exists
  const existingUser = await userService.getUserById(id);
  if (!existingUser) {
    throw new AppError('User not found', 404);
  }

  // Authorization check
  if (req.user.id !== id && req.user.role !== 'admin') {
    throw new AppError('Not authorized to update this user', 403);
  }

  const updatedUser = await userService.updateUser(id, updates);

  res.json({
    success: true,
    data: updatedUser,
    message: 'User updated successfully'
  });
});

exports.deleteUser = catchAsync(async (req, res) => {
  const { id } = req.params;

  const user = await userService.getUserById(id);
  if (!user) {
    throw new AppError('User not found', 404);
  }

  // Authorization check
  if (req.user.id !== id && req.user.role !== 'admin') {
    throw new AppError('Not authorized to delete this user', 403);
  }

  await userService.deleteUser(id);

  res.status(204).send();
});
```

## Authentication and Authorization

### JWT Authentication Middleware

```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken');
const userService = require('../services/userService');
const { AppError, catchAsync } = require('../utils/errorUtils');

exports.required = catchAsync(async (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new AppError('No token provided', 401);
  }

  const token = authHeader.substring(7);

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    const user = await userService.getUserById(decoded.id);
    if (!user) {
      throw new AppError('Token invalid', 401);
    }

    req.user = user;
    next();
  } catch (error) {
    if (error.name === 'JsonWebTokenError') {
      throw new AppError('Invalid token', 401);
    }
    if (error.name === 'TokenExpiredError') {
      throw new AppError('Token expired', 401);
    }
    throw error;
  }
});

exports.optional = catchAsync(async (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return next();
  }

  try {
    const token = authHeader.substring(7);
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await userService.getUserById(decoded.id);

    if (user) {
      req.user = user;
    }
  } catch (error) {
    // Silently fail for optional auth
  }

  next();
});

exports.requireRole = (roles) => {
  return (req, res, next) => {
    if (!req.user) {
      throw new AppError('Authentication required', 401);
    }

    if (!roles.includes(req.user.role)) {
      throw new AppError('Insufficient permissions', 403);
    }

    next();
  };
};
```

### Authentication Routes

```javascript
// routes/auth.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const validate = require('../middleware/validate');
const { authSchemas } = require('../utils/validationSchemas');

router.post('/register',
  validate(authSchemas.register),
  authController.register
);

router.post('/login',
  validate(authSchemas.login),
  authController.login
);

router.post('/refresh-token',
  validate(authSchemas.refreshToken),
  authController.refreshToken
);

router.post('/logout',
  authController.logout
);

router.post('/forgot-password',
  validate(authSchemas.forgotPassword),
  authController.forgotPassword
);

router.post('/reset-password',
  validate(authSchemas.resetPassword),
  authController.resetPassword
);

module.exports = router;

// controllers/authController.js
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const userService = require('../services/userService');
const emailService = require('../services/emailService');
const { AppError, catchAsync } = require('../utils/errorUtils');

const generateTokens = (userId) => {
  const accessToken = jwt.sign(
    { id: userId },
    process.env.JWT_SECRET,
    { expiresIn: process.env.JWT_EXPIRES_IN || '15m' }
  );

  const refreshToken = jwt.sign(
    { id: userId },
    process.env.REFRESH_TOKEN_SECRET,
    { expiresIn: '7d' }
  );

  return { accessToken, refreshToken };
};

exports.register = catchAsync(async (req, res) => {
  const { email, password, name } = req.body;

  const existingUser = await userService.getUserByEmail(email);
  if (existingUser) {
    throw new AppError('Email already registered', 409);
  }

  const hashedPassword = await bcrypt.hash(password, 12);

  const user = await userService.createUser({
    email,
    password: hashedPassword,
    name
  });

  const tokens = generateTokens(user._id);

  res.status(201).json({
    success: true,
    data: {
      user: {
        id: user._id,
        email: user.email,
        name: user.name
      },
      tokens
    },
    message: 'Registration successful'
  });
});

exports.login = catchAsync(async (req, res) => {
  const { email, password } = req.body;

  const user = await userService.getUserByEmail(email, '+password');
  if (!user) {
    throw new AppError('Invalid credentials', 401);
  }

  const isPasswordValid = await bcrypt.compare(password, user.password);
  if (!isPasswordValid) {
    throw new AppError('Invalid credentials', 401);
  }

  const tokens = generateTokens(user._id);

  res.json({
    success: true,
    data: {
      user: {
        id: user._id,
        email: user.email,
        name: user.name
      },
      tokens
    },
    message: 'Login successful'
  });
});
```

## Request Validation

### Validation Schemas

```javascript
// utils/validationSchemas.js
const Joi = require('joi');

const userSchemas = {
  create: Joi.object({
    name: Joi.string().min(2).max(50).required(),
    email: Joi.string().email().required(),
    password: Joi.string().min(8).pattern(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/
    ).required(),
    role: Joi.string().valid('user', 'admin').default('user')
  }),

  update: Joi.object({
    name: Joi.string().min(2).max(50),
    email: Joi.string().email(),
    role: Joi.string().valid('user', 'admin')
  }).min(1),

  patch: Joi.object({
    name: Joi.string().min(2).max(50),
    email: Joi.string().email(),
    status: Joi.string().valid('active', 'inactive')
  }).min(1)
};

const authSchemas = {
  register: Joi.object({
    name: Joi.string().min(2).max(50).required(),
    email: Joi.string().email().required(),
    password: Joi.string().min(8).pattern(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/
    ).required()
  }),

  login: Joi.object({
    email: Joi.string().email().required(),
    password: Joi.string().required()
  })
};

module.exports = { userSchemas, authSchemas };

// middleware/validate.js
const { AppError } = require('../utils/errorUtils');

module.exports = (schema) => {
  return (req, res, next) => {
    const { error } = schema.validate(req.body);

    if (error) {
      const message = error.details[0].message;
      throw new AppError(message, 400);
    }

    next();
  };
};
```

## Error Handling

### Comprehensive Error Handler

```javascript
// utils/errorUtils.js
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

const catchAsync = (fn) => {
  return (req, res, next) => {
    fn(req, res, next).catch(next);
  };
};

module.exports = { AppError, catchAsync };

// middleware/errorHandler.js
const { AppError } = require('../utils/errorUtils');

const handleCastErrorDB = (err) => {
  const message = `Invalid ${err.path}: ${err.value}`;
  return new AppError(message, 400);
};

const handleDuplicateFieldsDB = (err) => {
  const value = err.errmsg.match(/(["'])(\\?.)*?\1/)[0];
  const message = `Duplicate field value: ${value}. Please use another value!`;
  return new AppError(message, 400);
};

const handleValidationErrorDB = (err) => {
  const errors = Object.values(err.errors).map(el => el.message);
  const message = `Invalid input data. ${errors.join('. ')}`;
  return new AppError(message, 400);
};

const sendErrorDev = (err, res) => {
  res.status(err.statusCode).json({
    success: false,
    error: err,
    message: err.message,
    stack: err.stack
  });
};

const sendErrorProd = (err, res) => {
  // Operational, trusted error: send message to client
  if (err.isOperational) {
    res.status(err.statusCode).json({
      success: false,
      message: err.message
    });
  } else {
    // Programming or other unknown error: don't leak error details
    console.error('ERROR ðŸ’¥', err);

    res.status(500).json({
      success: false,
      message: 'Something went wrong!'
    });
  }
};

module.exports = (err, req, res, next) => {
  err.statusCode = err.statusCode || 500;
  err.status = err.status || 'error';

  if (process.env.NODE_ENV === 'development') {
    sendErrorDev(err, res);
  } else {
    let error = { ...err };
    error.message = err.message;

    if (error.name === 'CastError') error = handleCastErrorDB(error);
    if (error.code === 11000) error = handleDuplicateFieldsDB(error);
    if (error.name === 'ValidationError') error = handleValidationErrorDB(error);

    sendErrorProd(error, res);
  }
};
```

## Testing Your API

### Unit and Integration Tests

```javascript
// tests/user.test.js
const request = require('supertest');
const app = require('../src/app');
const User = require('../src/models/User');

describe('User API', () => {
  beforeEach(async () => {
    await User.deleteMany({});
  });

  describe('POST /api/users', () => {
    it('should create a new user', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'Password123!'
      };

      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.email).toBe(userData.email);
      expect(response.body.data.password).toBeUndefined();
    });

    it('should return error for duplicate email', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'Password123!'
      };

      await User.create(userData);

      await request(app)
        .post('/api/users')
        .send(userData)
        .expect(409);
    });
  });

  describe('GET /api/users/:id', () => {
    it('should get user by id', async () => {
      const user = await User.create({
        name: 'John Doe',
        email: 'john@example.com',
        password: 'hashedpassword'
      });

      const response = await request(app)
        .get(`/api/users/${user._id}`)
        .expect(200);

      expect(response.body.data.name).toBe(user.name);
    });

    it('should return 404 for non-existent user', async () => {
      const fakeId = '507f1f77bcf86cd799439011';

      await request(app)
        .get(`/api/users/${fakeId}`)
        .expect(404);
    });
  });
});
```

## Production Best Practices

### Environment Configuration

```javascript
// config/database.js
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error('Database connection failed:', error);
    process.exit(1);
  }
};

module.exports = connectDB;

// config/config.js
module.exports = {
  port: process.env.PORT || 3000,
  mongoUri: process.env.MONGODB_URI || 'mongodb://localhost:27017/myapi',
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
  jwtExpiresIn: process.env.JWT_EXPIRES_IN || '15m',
  nodeEnv: process.env.NODE_ENV || 'development',
  corsOrigins: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000']
};
```

### Logging and Monitoring

```javascript
// utils/logger.js
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'api' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

module.exports = logger;

// middleware/logger.js
const logger = require('../utils/logger');

module.exports = (req, res, next) => {
  logger.info(`${req.method} ${req.path} - ${req.ip}`);
  next();
};
```

## Conclusion

Building robust REST APIs with Node.js and Express requires attention to:

- **Structure**: Organized, maintainable code architecture
- **Security**: Authentication, authorization, input validation
- **Error Handling**: Comprehensive error management
- **Testing**: Unit and integration test coverage
- **Performance**: Caching, rate limiting, optimization
- **Monitoring**: Logging, metrics, health checks

Start with a solid foundation and gradually add complexity as your API grows. Focus on consistency, documentation, and following REST principles for the best developer experience.

Remember: a well-designed API is not just functional but also maintainable, secure, and developer-friendly.