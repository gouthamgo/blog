---
title: "Feature Engineering: The Art of Data Transformation"
description: "Master feature engineering techniques including feature selection, scaling, encoding, and dimensionality reduction with practical pandas and scikit-learn examples."
date: "2024-11-28"
author: "Tech Blogger"
tags: ["Machine Learning", "Data Science", "Feature Engineering"]
image: "/images/feature-engineering.jpg"
readTime: "9 min read"
---

# Feature Engineering: The Art of Data Transformation

Feature engineering is often considered the most critical aspect of machine learning success. It's the creative process of transforming raw data into meaningful features that make machine learning algorithms work effectively. As the saying goes: "garbage in, garbage out" — but with proper feature engineering, you can turn ordinary data into predictive gold.

## What is Feature Engineering?

Feature engineering is the process of selecting, modifying, or creating features from raw data to improve the performance of machine learning models. It bridges the gap between raw data and the algorithms that learn from it.

```python
# Raw data example
raw_data = {
    'timestamp': '2024-01-15 14:30:00',
    'price': 150.75,
    'customer_id': 'CUST_12345',
    'product_category': 'Electronics'
}

# Feature engineered version
engineered_features = {
    'hour': 14,
    'day_of_week': 1,  # Monday
    'is_weekend': 0,
    'price_log': 5.02,  # log(150.75)
    'price_category': 'medium',
    'customer_segment': 'premium',
    'electronics_flag': 1
}
```

## The Feature Engineering Process

The systematic approach to feature engineering involves several key steps:

```
📊 Raw Data → 🔍 Exploration → 🛠️ Transformation → ✅ Validation → 🎯 Selection
     ↓              ↓               ↓              ↓           ↓
  Collection    Understanding   Creation &      Performance   Optimal
  Integration    Patterns       Modification    Evaluation    Features
```

### Step 1: Data Exploration and Understanding

Before creating features, you must understand your data thoroughly:

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler, LabelEncoder, OneHotEncoder
from sklearn.feature_selection import SelectKBest, f_classif, RFE
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report

# Load and explore dataset
df = pd.read_csv('dataset.csv')

# Basic data exploration
print("Dataset Shape:", df.shape)
print("\nData Types:")
print(df.dtypes)

print("\nMissing Values:")
print(df.isnull().sum())

print("\nSummary Statistics:")
print(df.describe())

# Visualize data distributions
fig, axes = plt.subplots(2, 2, figsize=(15, 10))

# Numerical feature distributions
numerical_cols = df.select_dtypes(include=[np.number]).columns
for i, col in enumerate(numerical_cols[:4]):
    axes[i//2, i%2].hist(df[col], bins=30, alpha=0.7)
    axes[i//2, i%2].set_title(f'Distribution of {col}')
    axes[i//2, i%2].set_xlabel(col)
    axes[i//2, i%2].set_ylabel('Frequency')

plt.tight_layout()
plt.show()

# Correlation analysis
correlation_matrix = df.corr()
plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)
plt.title('Feature Correlation Matrix')
plt.show()
```

### Step 2: Handling Missing Values

Missing values require careful treatment as they can significantly impact model performance:

```python
class MissingValueHandler:
    """Comprehensive missing value handling"""

    def __init__(self, df):
        self.df = df.copy()
        self.missing_summary = self.analyze_missing_values()

    def analyze_missing_values(self):
        """Analyze patterns in missing values"""
        missing_data = pd.DataFrame({
            'column': self.df.columns,
            'missing_count': self.df.isnull().sum(),
            'missing_percentage': (self.df.isnull().sum() / len(self.df)) * 100
        })

        missing_data = missing_data[missing_data['missing_count'] > 0]
        missing_data = missing_data.sort_values('missing_percentage', ascending=False)

        return missing_data

    def handle_numerical_missing(self, strategy='median'):
        """Handle missing values in numerical columns"""
        numerical_cols = self.df.select_dtypes(include=[np.number]).columns

        for col in numerical_cols:
            if self.df[col].isnull().any():
                if strategy == 'mean':
                    fill_value = self.df[col].mean()
                elif strategy == 'median':
                    fill_value = self.df[col].median()
                elif strategy == 'mode':
                    fill_value = self.df[col].mode().iloc[0]
                elif strategy == 'forward_fill':
                    self.df[col].fillna(method='ffill', inplace=True)
                    continue
                elif strategy == 'backward_fill':
                    self.df[col].fillna(method='bfill', inplace=True)
                    continue

                self.df[col].fillna(fill_value, inplace=True)
                print(f"Filled {col} missing values with {strategy}: {fill_value:.2f}")

    def handle_categorical_missing(self, strategy='mode'):
        """Handle missing values in categorical columns"""
        categorical_cols = self.df.select_dtypes(include=['object']).columns

        for col in categorical_cols:
            if self.df[col].isnull().any():
                if strategy == 'mode':
                    fill_value = self.df[col].mode().iloc[0]
                elif strategy == 'unknown':
                    fill_value = 'Unknown'
                elif strategy == 'new_category':
                    fill_value = f'{col}_missing'

                self.df[col].fillna(fill_value, inplace=True)
                print(f"Filled {col} missing values with: {fill_value}")

    def create_missing_indicators(self):
        """Create binary indicators for missing values"""
        for col in self.missing_summary['column']:
            if col in self.df.columns:
                self.df[f'{col}_was_missing'] = self.df[col].isnull().astype(int)

        return self.df

# Usage example
missing_handler = MissingValueHandler(df)
print("Missing Value Analysis:")
print(missing_handler.missing_summary)

# Handle missing values
missing_handler.handle_numerical_missing(strategy='median')
missing_handler.handle_categorical_missing(strategy='mode')

# Create missing indicators if needed
df_processed = missing_handler.create_missing_indicators()
```

### Step 3: Numerical Feature Engineering

Transform numerical features to improve model performance:

```python
class NumericalFeatureEngineer:
    """Advanced numerical feature engineering techniques"""

    def __init__(self, df):
        self.df = df.copy()
        self.scalers = {}

    def create_polynomial_features(self, columns, degree=2):
        """Create polynomial features"""
        from sklearn.preprocessing import PolynomialFeatures

        poly = PolynomialFeatures(degree=degree, include_bias=False)
        poly_features = poly.fit_transform(self.df[columns])

        feature_names = poly.get_feature_names_out(columns)
        poly_df = pd.DataFrame(poly_features, columns=feature_names, index=self.df.index)

        # Remove original features to avoid duplication
        original_cols = [col for col in feature_names if ' ' not in col and '^' not in col]
        poly_df = poly_df.drop(columns=original_cols)

        self.df = pd.concat([self.df, poly_df], axis=1)
        return self

    def create_interaction_features(self, column_pairs):
        """Create interaction features between column pairs"""
        for col1, col2 in column_pairs:
            if col1 in self.df.columns and col2 in self.df.columns:
                # Multiplication interaction
                self.df[f'{col1}_x_{col2}'] = self.df[col1] * self.df[col2]

                # Ratio interaction (avoid division by zero)
                self.df[f'{col1}_div_{col2}'] = self.df[col1] / (self.df[col2] + 1e-8)

                # Difference interaction
                self.df[f'{col1}_minus_{col2}'] = self.df[col1] - self.df[col2]

        return self

    def create_binning_features(self, column, n_bins=5, strategy='quantile'):
        """Create binning features from continuous variables"""
        if strategy == 'quantile':
            bins = pd.qcut(self.df[column], q=n_bins, labels=False, duplicates='drop')
        elif strategy == 'uniform':
            bins = pd.cut(self.df[column], bins=n_bins, labels=False)

        self.df[f'{column}_bin'] = bins

        # Create one-hot encoded bins
        bin_dummies = pd.get_dummies(bins, prefix=f'{column}_bin', dtype=int)
        self.df = pd.concat([self.df, bin_dummies], axis=1)

        return self

    def apply_transformations(self, transformations):
        """Apply various mathematical transformations"""
        for column, transform_type in transformations.items():
            if column not in self.df.columns:
                continue

            original_col = self.df[column].copy()

            if transform_type == 'log':
                # Handle negative values and zeros
                self.df[f'{column}_log'] = np.log1p(original_col.clip(lower=0))

            elif transform_type == 'sqrt':
                self.df[f'{column}_sqrt'] = np.sqrt(original_col.clip(lower=0))

            elif transform_type == 'reciprocal':
                self.df[f'{column}_reciprocal'] = 1 / (original_col + 1e-8)

            elif transform_type == 'square':
                self.df[f'{column}_square'] = original_col ** 2

            elif transform_type == 'box_cox':
                from scipy import stats
                transformed, lambda_val = stats.boxcox(original_col + 1)
                self.df[f'{column}_boxcox'] = transformed

        return self

    def create_statistical_features(self, group_by_col, agg_cols):
        """Create statistical features grouped by categorical variables"""
        for agg_col in agg_cols:
            if agg_col in self.df.columns and group_by_col in self.df.columns:
                # Group statistics
                group_stats = self.df.groupby(group_by_col)[agg_col].agg([
                    'mean', 'median', 'std', 'min', 'max', 'count'
                ])

                # Add suffix to column names
                group_stats.columns = [f'{agg_col}_{group_by_col}_{stat}'
                                     for stat in group_stats.columns]

                # Merge back to original dataframe
                self.df = self.df.merge(group_stats, left_on=group_by_col,
                                      right_index=True, how='left')

        return self

# Example usage
numerical_engineer = NumericalFeatureEngineer(df_processed)

# Create polynomial features for selected columns
numerical_engineer.create_polynomial_features(['age', 'income'], degree=2)

# Create interaction features
numerical_engineer.create_interaction_features([('age', 'income'), ('price', 'quantity')])

# Apply transformations
transformations = {
    'price': 'log',
    'income': 'sqrt',
    'age': 'square'
}
numerical_engineer.apply_transformations(transformations)

# Create binning features
numerical_engineer.create_binning_features('age', n_bins=5, strategy='quantile')

# Create statistical features
numerical_engineer.create_statistical_features('category', ['price', 'quantity'])

df_numerical = numerical_engineer.df
```

### Step 4: Categorical Feature Engineering

Transform categorical variables into numerical representations:

```python
class CategoricalFeatureEngineer:
    """Advanced categorical feature engineering"""

    def __init__(self, df):
        self.df = df.copy()
        self.encoders = {}

    def label_encode(self, columns):
        """Apply label encoding to categorical columns"""
        for col in columns:
            if col in self.df.columns:
                le = LabelEncoder()
                self.df[f'{col}_label_encoded'] = le.fit_transform(self.df[col].astype(str))
                self.encoders[f'{col}_label'] = le

        return self

    def one_hot_encode(self, columns, drop_first=True, max_categories=10):
        """Apply one-hot encoding with category limitation"""
        for col in columns:
            if col in self.df.columns:
                # Limit categories to prevent explosion
                value_counts = self.df[col].value_counts()
                top_categories = value_counts.head(max_categories).index.tolist()

                # Replace infrequent categories with 'Other'
                df_temp = self.df[col].copy()
                df_temp = df_temp.where(df_temp.isin(top_categories), 'Other')

                # One-hot encode
                dummies = pd.get_dummies(df_temp, prefix=col, drop_first=drop_first, dtype=int)
                self.df = pd.concat([self.df, dummies], axis=1)

        return self

    def target_encode(self, columns, target_col, smoothing_factor=10):
        """Apply target encoding (mean encoding) with smoothing"""
        overall_mean = self.df[target_col].mean()

        for col in columns:
            if col in self.df.columns:
                # Calculate category statistics
                category_stats = self.df.groupby(col)[target_col].agg(['mean', 'count'])

                # Apply smoothing
                smoothed_mean = ((category_stats['mean'] * category_stats['count'] +
                                overall_mean * smoothing_factor) /
                               (category_stats['count'] + smoothing_factor))

                # Map back to original dataframe
                self.df[f'{col}_target_encoded'] = self.df[col].map(smoothed_mean)

                # Fill missing values with overall mean
                self.df[f'{col}_target_encoded'].fillna(overall_mean, inplace=True)

        return self

    def frequency_encode(self, columns):
        """Encode categories by their frequency"""
        for col in columns:
            if col in self.df.columns:
                freq_encoding = self.df[col].value_counts().to_dict()
                self.df[f'{col}_frequency_encoded'] = self.df[col].map(freq_encoding)

        return self

    def binary_encode(self, columns):
        """Apply binary encoding to reduce dimensionality"""
        import category_encoders as ce

        for col in columns:
            if col in self.df.columns:
                be = ce.BinaryEncoder(cols=[col])
                binary_encoded = be.fit_transform(self.df[[col]])

                # Rename columns
                binary_encoded.columns = [f'{col}_binary_{i}'
                                        for i in range(len(binary_encoded.columns))]

                self.df = pd.concat([self.df, binary_encoded], axis=1)
                self.encoders[f'{col}_binary'] = be

        return self

    def create_category_combinations(self, column_pairs):
        """Create new features from category combinations"""
        for col1, col2 in column_pairs:
            if col1 in self.df.columns and col2 in self.df.columns:
                self.df[f'{col1}_{col2}_combo'] = (
                    self.df[col1].astype(str) + '_' + self.df[col2].astype(str)
                )

        return self

# Example usage
categorical_engineer = CategoricalFeatureEngineer(df_numerical)

# Identify categorical columns
categorical_cols = df_numerical.select_dtypes(include=['object']).columns.tolist()
print("Categorical columns:", categorical_cols)

# Apply different encoding techniques
if 'category' in categorical_cols:
    categorical_engineer.one_hot_encode(['category'], max_categories=5)

if 'subcategory' in categorical_cols:
    categorical_engineer.label_encode(['subcategory'])

# If we have a target variable
if 'target' in df_numerical.columns and 'brand' in categorical_cols:
    categorical_engineer.target_encode(['brand'], 'target', smoothing_factor=10)

categorical_engineer.frequency_encode(['category'] if 'category' in categorical_cols else [])

# Create category combinations
if len(categorical_cols) >= 2:
    categorical_engineer.create_category_combinations([(categorical_cols[0], categorical_cols[1])])

df_categorical = categorical_engineer.df
```

### Step 5: Time-Based Feature Engineering

Extract meaningful features from temporal data:

```python
class TemporalFeatureEngineer:
    """Time-based feature engineering"""

    def __init__(self, df, datetime_col):
        self.df = df.copy()
        self.datetime_col = datetime_col

        # Ensure datetime column is properly parsed
        self.df[datetime_col] = pd.to_datetime(self.df[datetime_col])

    def extract_basic_time_features(self):
        """Extract basic time components"""
        dt_col = self.df[self.datetime_col]

        self.df[f'{self.datetime_col}_year'] = dt_col.dt.year
        self.df[f'{self.datetime_col}_month'] = dt_col.dt.month
        self.df[f'{self.datetime_col}_day'] = dt_col.dt.day
        self.df[f'{self.datetime_col}_hour'] = dt_col.dt.hour
        self.df[f'{self.datetime_col}_minute'] = dt_col.dt.minute
        self.df[f'{self.datetime_col}_weekday'] = dt_col.dt.dayofweek
        self.df[f'{self.datetime_col}_quarter'] = dt_col.dt.quarter
        self.df[f'{self.datetime_col}_day_of_year'] = dt_col.dt.dayofyear
        self.df[f'{self.datetime_col}_week_of_year'] = dt_col.dt.isocalendar().week

        return self

    def create_cyclical_features(self):
        """Create cyclical representations of time features"""
        dt_col = self.df[self.datetime_col]

        # Hour cyclical features
        self.df[f'{self.datetime_col}_hour_sin'] = np.sin(2 * np.pi * dt_col.dt.hour / 24)
        self.df[f'{self.datetime_col}_hour_cos'] = np.cos(2 * np.pi * dt_col.dt.hour / 24)

        # Day of week cyclical features
        self.df[f'{self.datetime_col}_weekday_sin'] = np.sin(2 * np.pi * dt_col.dt.dayofweek / 7)
        self.df[f'{self.datetime_col}_weekday_cos'] = np.cos(2 * np.pi * dt_col.dt.dayofweek / 7)

        # Month cyclical features
        self.df[f'{self.datetime_col}_month_sin'] = np.sin(2 * np.pi * dt_col.dt.month / 12)
        self.df[f'{self.datetime_col}_month_cos'] = np.cos(2 * np.pi * dt_col.dt.month / 12)

        return self

    def create_time_flags(self):
        """Create binary flags for specific time periods"""
        dt_col = self.df[self.datetime_col]

        # Weekend flag
        self.df[f'{self.datetime_col}_is_weekend'] = (dt_col.dt.dayofweek >= 5).astype(int)

        # Business hours flag
        self.df[f'{self.datetime_col}_is_business_hours'] = (
            (dt_col.dt.hour >= 9) & (dt_col.dt.hour < 17) &
            (dt_col.dt.dayofweek < 5)
        ).astype(int)

        # Holiday flag (simplified example)
        holidays = ['2024-01-01', '2024-07-04', '2024-12-25']  # Add more holidays
        holiday_dates = pd.to_datetime(holidays)
        self.df[f'{self.datetime_col}_is_holiday'] = dt_col.dt.date.isin(
            holiday_dates.date
        ).astype(int)

        # Peak hours flag
        peak_hours = [8, 9, 17, 18, 19]  # Rush hours
        self.df[f'{self.datetime_col}_is_peak_hour'] = dt_col.dt.hour.isin(peak_hours).astype(int)

        return self

    def create_lag_features(self, value_col, lags=[1, 7, 30]):
        """Create lag features for time series data"""
        self.df = self.df.sort_values(self.datetime_col)

        for lag in lags:
            self.df[f'{value_col}_lag_{lag}'] = self.df[value_col].shift(lag)

        return self

    def create_rolling_features(self, value_col, windows=[7, 30]):
        """Create rolling window features"""
        self.df = self.df.sort_values(self.datetime_col)

        for window in windows:
            # Rolling statistics
            rolling = self.df[value_col].rolling(window=window)

            self.df[f'{value_col}_rolling_mean_{window}'] = rolling.mean()
            self.df[f'{value_col}_rolling_std_{window}'] = rolling.std()
            self.df[f'{value_col}_rolling_min_{window}'] = rolling.min()
            self.df[f'{value_col}_rolling_max_{window}'] = rolling.max()

            # Rolling percentiles
            self.df[f'{value_col}_rolling_median_{window}'] = rolling.median()
            self.df[f'{value_col}_rolling_q25_{window}'] = rolling.quantile(0.25)
            self.df[f'{value_col}_rolling_q75_{window}'] = rolling.quantile(0.75)

        return self

# Example usage (if datetime column exists)
if 'timestamp' in df_categorical.columns:
    temporal_engineer = TemporalFeatureEngineer(df_categorical, 'timestamp')

    temporal_engineer.extract_basic_time_features()
    temporal_engineer.create_cyclical_features()
    temporal_engineer.create_time_flags()

    # If we have a value column for time series features
    if 'sales' in df_categorical.columns:
        temporal_engineer.create_lag_features('sales', lags=[1, 7])
        temporal_engineer.create_rolling_features('sales', windows=[7, 14])

    df_temporal = temporal_engineer.df
else:
    df_temporal = df_categorical
```

## Feature Selection Techniques

Not all engineered features will improve model performance. Feature selection helps identify the most valuable features:

```python
class FeatureSelector:
    """Advanced feature selection techniques"""

    def __init__(self, X, y):
        self.X = X
        self.y = y
        self.selected_features = {}
        self.feature_scores = {}

    def univariate_selection(self, k=20, score_func=f_classif):
        """Select features based on univariate statistical tests"""
        selector = SelectKBest(score_func=score_func, k=k)
        X_selected = selector.fit_transform(self.X, self.y)

        selected_features = self.X.columns[selector.get_support()]
        feature_scores = dict(zip(self.X.columns, selector.scores_))

        self.selected_features['univariate'] = selected_features.tolist()
        self.feature_scores['univariate'] = feature_scores

        return selected_features, feature_scores

    def recursive_feature_elimination(self, estimator=None, n_features=20):
        """Recursive feature elimination with cross-validation"""
        if estimator is None:
            estimator = RandomForestClassifier(n_estimators=100, random_state=42)

        rfe = RFE(estimator=estimator, n_features_to_select=n_features)
        X_selected = rfe.fit_transform(self.X, self.y)

        selected_features = self.X.columns[rfe.support_]
        feature_ranking = dict(zip(self.X.columns, rfe.ranking_))

        self.selected_features['rfe'] = selected_features.tolist()
        self.feature_scores['rfe'] = feature_ranking

        return selected_features, feature_ranking

    def feature_importance_selection(self, estimator=None, threshold=0.01):
        """Select features based on tree-based importance"""
        if estimator is None:
            estimator = RandomForestClassifier(n_estimators=100, random_state=42)

        estimator.fit(self.X, self.y)

        # Get feature importances
        importances = dict(zip(self.X.columns, estimator.feature_importances_))

        # Select features above threshold
        selected_features = [feat for feat, imp in importances.items() if imp >= threshold]

        self.selected_features['importance'] = selected_features
        self.feature_scores['importance'] = importances

        return selected_features, importances

    def correlation_filter(self, threshold=0.95):
        """Remove highly correlated features"""
        # Calculate correlation matrix
        corr_matrix = self.X.corr().abs()

        # Find pairs of highly correlated features
        upper_triangle = corr_matrix.where(
            np.triu(np.ones(corr_matrix.shape), k=1).astype(bool)
        )

        # Find features to drop
        high_corr_features = [column for column in upper_triangle.columns
                            if any(upper_triangle[column] > threshold)]

        # Features to keep
        selected_features = [col for col in self.X.columns if col not in high_corr_features]

        self.selected_features['correlation_filter'] = selected_features

        return selected_features, high_corr_features

    def variance_threshold_filter(self, threshold=0.01):
        """Remove features with low variance"""
        from sklearn.feature_selection import VarianceThreshold

        selector = VarianceThreshold(threshold=threshold)
        X_selected = selector.fit_transform(self.X)

        selected_features = self.X.columns[selector.get_support()]
        variances = dict(zip(self.X.columns, self.X.var()))

        self.selected_features['variance_threshold'] = selected_features.tolist()
        self.feature_scores['variance_threshold'] = variances

        return selected_features, variances

    def combine_selections(self, methods=['univariate', 'rfe', 'importance'], min_votes=2):
        """Combine multiple feature selection methods"""
        if not self.selected_features:
            print("Run feature selection methods first!")
            return []

        # Count votes for each feature
        feature_votes = {}
        for method in methods:
            if method in self.selected_features:
                for feature in self.selected_features[method]:
                    feature_votes[feature] = feature_votes.get(feature, 0) + 1

        # Select features with minimum votes
        final_features = [feat for feat, votes in feature_votes.items()
                         if votes >= min_votes]

        return final_features, feature_votes

# Example usage
# Assume we have features and target
feature_columns = df_temporal.select_dtypes(include=[np.number]).columns.tolist()

# Remove target if it exists
if 'target' in feature_columns:
    feature_columns.remove('target')
    X = df_temporal[feature_columns]
    y = df_temporal['target']

    # Initialize feature selector
    selector = FeatureSelector(X, y)

    # Apply different selection methods
    univariate_features, univariate_scores = selector.univariate_selection(k=20)
    print("Top 20 Univariate Features:", len(univariate_features))

    rfe_features, rfe_ranking = selector.recursive_feature_elimination(n_features=15)
    print("RFE Selected Features:", len(rfe_features))

    importance_features, importances = selector.feature_importance_selection(threshold=0.01)
    print("Important Features:", len(importance_features))

    # Remove correlated features
    selected_features, dropped_features = selector.correlation_filter(threshold=0.95)
    print("After correlation filter:", len(selected_features))

    # Remove low variance features
    variance_features, variances = selector.variance_threshold_filter(threshold=0.01)
    print("After variance filter:", len(variance_features))

    # Combine selections
    final_features, vote_counts = selector.combine_selections(min_votes=2)
    print("Final selected features:", len(final_features))

    # Visualize feature importance
    plt.figure(figsize=(12, 8))
    sorted_importances = sorted(importances.items(), key=lambda x: x[1], reverse=True)[:20]
    features, scores = zip(*sorted_importances)

    plt.barh(range(len(features)), scores)
    plt.yticks(range(len(features)), features)
    plt.xlabel('Feature Importance')
    plt.title('Top 20 Most Important Features')
    plt.gca().invert_yaxis()
    plt.tight_layout()
    plt.show()
```

## Evaluating Feature Engineering Impact

Always measure the impact of your feature engineering efforts:

```python
def evaluate_feature_engineering_impact(original_features, engineered_features, target, test_size=0.2):
    """Compare model performance before and after feature engineering"""

    # Prepare data
    X_original = original_features
    X_engineered = engineered_features
    y = target

    # Split data
    X_orig_train, X_orig_test, y_train, y_test = train_test_split(
        X_original, y, test_size=test_size, random_state=42, stratify=y
    )

    X_eng_train, X_eng_test, _, _ = train_test_split(
        X_engineered, y, test_size=test_size, random_state=42, stratify=y
    )

    # Train models
    models = {
        'RandomForest': RandomForestClassifier(n_estimators=100, random_state=42),
        'LogisticRegression': LogisticRegression(random_state=42, max_iter=1000)
    }

    results = {}

    for model_name, model in models.items():
        # Original features
        model_orig = model.__class__(**model.get_params())
        model_orig.fit(X_orig_train, y_train)
        orig_score = model_orig.score(X_orig_test, y_test)

        # Engineered features
        model_eng = model.__class__(**model.get_params())
        model_eng.fit(X_eng_train, y_train)
        eng_score = model_eng.score(X_eng_test, y_test)

        results[model_name] = {
            'original_score': orig_score,
            'engineered_score': eng_score,
            'improvement': eng_score - orig_score,
            'improvement_percent': ((eng_score - orig_score) / orig_score) * 100
        }

    return results

# Create comparison if we have original and engineered features
if 'target' in df_temporal.columns:
    # Original features (first few columns)
    original_cols = df.select_dtypes(include=[np.number]).columns[:5]

    results = evaluate_feature_engineering_impact(
        df[original_cols],
        X[final_features] if 'final_features' in locals() else X,
        y
    )

    print("Feature Engineering Impact:")
    print("=" * 50)
    for model, scores in results.items():
        print(f"\n{model}:")
        print(f"  Original Score: {scores['original_score']:.4f}")
        print(f"  Engineered Score: {scores['engineered_score']:.4f}")
        print(f"  Improvement: {scores['improvement']:.4f} ({scores['improvement_percent']:.2f}%)")
```

## Advanced Feature Engineering Techniques

### Automated Feature Engineering

```python
class AutoFeatureEngineer:
    """Automated feature engineering pipeline"""

    def __init__(self, df, target_col):
        self.df = df
        self.target_col = target_col
        self.generated_features = []

    def auto_generate_features(self):
        """Automatically generate features based on data types and patterns"""

        numerical_cols = self.df.select_dtypes(include=[np.number]).columns.tolist()
        if self.target_col in numerical_cols:
            numerical_cols.remove(self.target_col)

        categorical_cols = self.df.select_dtypes(include=['object']).columns.tolist()

        # Generate numerical interactions
        for i, col1 in enumerate(numerical_cols):
            for col2 in numerical_cols[i+1:]:
                # Ratio features
                self.df[f'{col1}_div_{col2}'] = self.df[col1] / (self.df[col2] + 1e-8)
                self.generated_features.append(f'{col1}_div_{col2}')

                # Product features
                self.df[f'{col1}_mul_{col2}'] = self.df[col1] * self.df[col2]
                self.generated_features.append(f'{col1}_mul_{col2}')

        # Generate statistical features for categoricals
        for cat_col in categorical_cols:
            for num_col in numerical_cols:
                group_stats = self.df.groupby(cat_col)[num_col].transform(['mean', 'std'])
                self.df[f'{num_col}_{cat_col}_mean'] = group_stats['mean']
                self.df[f'{num_col}_{cat_col}_std'] = group_stats['std']

                self.generated_features.extend([
                    f'{num_col}_{cat_col}_mean',
                    f'{num_col}_{cat_col}_std'
                ])

        return self.generated_features

# Auto feature engineering example
if 'target' in df_temporal.columns:
    auto_engineer = AutoFeatureEngineer(df_temporal, 'target')
    new_features = auto_engineer.auto_generate_features()
    print(f"Generated {len(new_features)} new features automatically")
```

## Best Practices for Feature Engineering

### 1. **Domain Knowledge is Key**
- Understand the business context and data meaning
- Collaborate with domain experts
- Consider external data sources

### 2. **Iterative Process**
- Start simple and gradually add complexity
- Test each feature's impact individually
- Remove features that don't help

### 3. **Avoid Data Leakage**
```python
# ❌ Wrong: Using future information
df['target_next_month'] = df['target'].shift(-1)  # Data leakage!

# ✅ Correct: Using only past information
df['sales_last_month'] = df['sales'].shift(1)
```

### 4. **Scale and Normalize Appropriately**
```python
# Different scaling for different algorithms
scalers = {
    'StandardScaler': StandardScaler(),
    'MinMaxScaler': MinMaxScaler(),
    'RobustScaler': RobustScaler(),
    'Normalizer': Normalizer()
}

for name, scaler in scalers.items():
    X_scaled = scaler.fit_transform(X)
    print(f"{name}: {X_scaled.mean():.3f} ± {X_scaled.std():.3f}")
```

### 5. **Handle Missing Values Thoughtfully**
- Missing values can be informative
- Consider multiple imputation strategies
- Create missing value indicators when appropriate

## Conclusion

Feature engineering is both an art and a science that can dramatically improve machine learning model performance. The key principles to remember:

### 🎯 **Core Principles**
- **Domain Knowledge**: Understanding your data context is crucial
- **Iterative Approach**: Test features individually and in combinations
- **Quality over Quantity**: More features don't always mean better performance
- **Validation**: Always measure the impact of your engineering efforts

### 🛠️ **Essential Techniques**
- **Numerical Transformations**: Log, sqrt, polynomial, and interaction features
- **Categorical Encoding**: One-hot, target, frequency, and binary encoding
- **Temporal Features**: Extract time components and create cyclical features
- **Feature Selection**: Remove redundant and irrelevant features

### 📊 **Advanced Methods**
- **Statistical Features**: Group-based aggregations and rolling statistics
- **Automated Engineering**: Systematic feature generation and testing
- **Dimensionality Reduction**: PCA, t-SNE for high-dimensional data
- **Feature Interactions**: Combining features for non-linear relationships

Remember: the best features often come from deep understanding of your problem domain combined with creative thinking about how different variables might interact. Start with simple transformations, validate their impact, and gradually build complexity.

Feature engineering is where data science meets creativity — the features you create today might be the breakthrough your model needs tomorrow! 🚀